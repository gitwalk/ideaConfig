<application>
  <component name="AppStorage">
    <histories>
      <item value="update transaction ID if necessary" />
      <item value="queued" />
      <item value="protocol" />
      <item value="update catalog and schema if present" />
      <item value="process Internal" />
      <item value="read Internal" />
      <item value="raptor" />
      <item value="Parquet" />
      <item value="prepare" />
      <item value="PREFILLED" />
      <item value="Aggregate" />
      <item value="Footer" />
      <item value="grant" />
      <item value="SchedulingLifespanManager tracks how far each Lifespan has been scheduled. Here is an example. // Let's say there are 4 source pipelines/nodes: A, B, C, and D, in scheduling order. // And we're processing 3 concurrent lifespans at a time. In this case, we could have // // * Lifespan 10: A B [C] D; i.e. Pipeline A and B has finished scheduling (but not necessarily finished running). // * Lifespan 20: [A] B C D // * Lifespan 30: A [B] C D" />
      <item value="For each driver in a task, it belong to a pipeline and a driver life cycle. // Pipeline and driver life cycle are two perpendicular organizations of tasks" />
      <item value="hive File Context" />
      <item value="encryption Information" />
      <item value="domain Predicate" />
      <item value="prefilled Values" />
      <item value="user-friendly representation of the expression similar to original SQL" />
      <item value="A set of services/utilities that are helpful for connectors to operate on row expressions" />
      <item value="get Domain Translator" />
      <item value="comment" />
      <item value="effective Predicate" />
      <item value="assure the page is in memory before handing to another operator" />
      <item value="regular" />
      <item value="will be present if the partition has a different schema (column type, column name) for the column" />
      <item value="If coercion does not affect bucket number calculation, coercion doesn't need to be applied here. // Otherwise, read of this partition should not be allowed. // (Alternatively, the partition could be read as an unbucketed partition. This is not implemented.)" />
      <item value="delegate" />
      <item value="advance" />
      <item value="Bucket" />
      <item value="Coercer" />
      <item value="Coercion" />
      <item value="Cursor" />
      <item value="if this connector does not support reading tables record at a time" />
      <item value="if this connector does not support reading tables page at a time" />
      <item value="transaction" />
      <item value="Bridging" />
      <item value="** * Timeout in nanoseconds for idle threads waiting for work. * Threads use this timeout when there are more than corePoolSize * present or if allowCoreThreadTimeOut. Otherwise they wait * forever for new work." />
      <item value="Are workers subject to culling" />
      <item value="subject" />
      <item value="culling" />
      <item value="handle secure connection if specified" />
      <item value="create Binary Transport" />
      <item value="Always throws RejectedExecutionException" />
      <item value="If we cannot queue task, then we try to add a new * thread. If it fails, we know we are shut down or saturated * and so reject the task." />
      <item value="If a task can be successfully queued, then we still need * to double-check whether we should have added a thread * (because existing ones died since last checking) or that * the pool shut down since entry into this method. So we * recheck state and if necessary roll back the enqueuing if * stopped, or start a new thread if there are none." />
      <item value="If fewer than corePoolSize threads are running, try to * start a new thread with the given command as its first * task. The call to addWorker atomically checks runState and * workerCount, and so prevents false alarms that would add * threads when it shouldn't, by returning false." />
      <item value="suitable" />
      <item value="Strategy" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="773" />
        <entry key="ENGLISH" value="774" />
        <entry key="DANISH" value="2" />
        <entry key="GERMAN" value="1" />
        <entry key="FRENCH" value="3" />
        <entry key="FILIPINO" value="1" />
        <entry key="DUTCH" value="6" />
        <entry key="KURDISH" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="NORWEGIAN" value="1" />
        <entry key="SWEDISH" value="2" />
        <entry key="ITALIAN" value="1" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>