<application>
  <component name="AppStorage">
    <histories>
      <item value="Compile a new query. Any currently-planned query associated with this Driver is discarded. * Do not reset id for inner queries(index, etc). Task ids are used for task identity check" />
      <item value="Both UDF and UDAF functions can imply order for analytical functions" />
      <item value="Validate the function name" />
      <item value="SHOW FUNCTIONS is deprecated, please use SHOW FUNCTIONS LIKE instead." />
      <item value="Try qualifying with current db name for permanent functions" />
      <item value="First try without qualifiers - would resolve builtin/temp functions" />
      <item value="Missing over clause for function" />
      <item value="Looks up the function name in the registry. If enabled, will attempt to search the metastore * for the function." />
      <item value="Operator argument type mismatch" />
      <item value="Function argument type mismatch" />
      <item value="expression Tree" />
      <item value="Generate Resolved Parse tree from syntax tree" />
      <item value="// resultSchema will be null if // (1) cbo is disabled; // (2) or cbo is enabled with AST return path (whether succeeded or not, // resultSchema will be re-initialized) // It will only be not null if cbo is enabled with new return path and it // succeeds." />
      <item value="Set the semijoin hints in parse context" />
      <item value="// Generate lineage info for create view statements // if LineageLogger hook is configured. // Add the transformation that computes the lineage information." />
      <item value="// Flush the metastore cache. This assures that we don't pick up objects from a previous // query running in this same thread. This has to be done after we get our semantic // analyzer (this is when the connection to the metastore is made) but before we analyze, // because at that point we need access to the objects." />
      <item value="clear CurrentFunctionsInUse set, to capture new set of functions // that SemanticAnalyzer finds are in use" />
      <item value="Trigger query hook before compilation" />
      <item value="No FileSystem for scheme: hdfs" />
      <item value="is encrypted" />
      <item value="Unable to determine" />
      <item value="// deferClose indicates if the close/destroy should be deferred when the process has been // interrupted, it should be set to true if the compile is called within another method like // runInternal, which defers the close to the called in that method." />
      <item value="Get a Schema with fields represented with native Hive types" />
      <item value="validate the plan" />
      <item value="Compile a new query. Any currently-planned query associated with this Driver is discarded. * Do not reset id for inner queries(index, etc). Task ids are used for task identity check. *" />
      <item value="Pass lineageState when a driver instantiates another Driver to run // or compile another query" />
      <item value="* The compiler compiles the command, by creating a QueryPlan from a String command. * Also opens a transaction if necessary." />
      <item value="// The dispatcher fires the processor corresponding to the closest matching // rule and passes the context along" />
      <item value="// create a walker which walks the tree in a DFS manner while maintaining // the operator stack. The dispatcher // generates the plan from the operator tree" />
      <item value="Hive sends with both old and new table names in the outputs which is weird. So skipping that with the below check" />
      <item value="change the location of position alias process here" />
      <item value="Get Optimized AST for the given QB tree in the semAnalyzer" />
      <item value="fetch all the hints in qb" />
      <item value="Fix up the query for materialization rebuild" />
      <item value="Fix up the query for insert/ctas/materialized views" />
      <item value="Convert Plan to AST" />
      <item value="* Tries to optimize FROM clause of multi-insert. No attempt to optimize insert clauses of the query. * Returns true if rewriting is successful, false otherwise." />
      <item value="Regen OP plan from optimized AST" />
      <item value="Include cost as provided by Calcite" />
      <item value="Recurse over the subqueries to fill the subquery part of the plan" />
      <item value="First generate all the opInfos for the elements in the from clause" />
      <item value="Generate Parse Context for Optimizer &amp; Physical compiler" />
      <item value="Invoke all the transformations one-by-one, and alter the query plan" />
      <item value="transformations" />
      <item value="Retrieve information about cache usage for the query." />
      <item value="Determines transaction type based on query AST" />
      <item value="Determines transaction type based on query AST." />
      <item value="SemanticAnalyzerFactory also sets the hive operation in query state" />
      <item value="deferClose indicates if the close/destroy should be deferred when the process has been" />
      <item value="Internal" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="308" />
        <entry key="ENGLISH" value="309" />
        <entry key="DUTCH" value="2" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>