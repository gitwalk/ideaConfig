<application>
  <component name="AppStorage">
    <histories>
      <item value="// Remember all threads that were running at the time we started line processing. // Hook up the custom Ctrl+C handler while processing this line" />
      <item value="hive Variable Source" />
      <item value="Compile a new query, but potentially reset taskID counter. Not resetting task counter * is useful for generating re-entrant QL queries." />
      <item value="/*It's imperative that {@code acquireLocks()} is called for all commands so that HiveTxnManager can transition its state machine correctly*/" />
      <item value="the sinks and DDL cannot coexist at this time; but if they could we would // need to make sure we don't get two write IDs for the same table" />
      <item value="it's possible to have &gt; 1 FileSink writing to the same table/partition * e.g. Merge stmt, multi-insert stmt when mixing DP and SP writes * Insert ... Select ... Union All Select ... using * {@link org.apache.hadoop.hive.ql.exec.AbstractFileMergeOperator#UNION_SUDBIR_PREFIX} */" />
      <item value="//sorting makes tests easier to write since file names and ROW__IDs depend on statementId //so this makes (file name -&gt; data) mapping stable" />
      <item value="Set the table write id in all of the acid file sinks" />
      <item value="Acquire read and write locks needed by the statement. The list of objects to be locked are * obtained from the inputs and outputs populated by the compiler. Locking strategy depends on * HiveTxnManager and HiveLockManager configured" />
      <item value="the sinks and DDL cannot coexist at this time; but if they could we would // need to make sure we don't get two write IDs for the same table." />
      <item value="does not add back up task here, because back up task should be the same // type of the original task" />
      <item value="require" />
      <item value="Lock operations themselves don't require the lock." />
      <item value="Concurrency mode is disabled, not creating a lock manager" />
      <item value="Assumes the query has already been compiled" />
      <item value="the release here will do nothing because there is no lock" />
      <item value="since set autocommit starts an implicit txn, close it" />
      <item value="Valid" />
      <item value="Lock acquisition should be moved before analyze, this is a bit hackish." />
      <item value="Currently, we acquire a snapshot, we compile the query wrt that snapshot, // and then, we acquire locks. If snapshot is still valid, we continue as usual. // But if snapshot is not valid, we recompile the query." />
      <item value="Snapshot was outdated when locks were acquired, hence regenerate context, // txn list and retry" />
      <item value="Checks whether txn list has been invalidated while planning the query. // This would happen if query requires exclusive/semi-shared lock, and there // has been a committed transaction on the table over which the lock is // required." />
      <item value="Trigger query hooks after query completes its execution." />
      <item value="// compile and execute can get called from different threads in case of HS2 // so clear timing in this thread's Hive object before proceeding." />
      <item value="// Snapshot was outdated when locks were acquired, hence regenerate context, // txn list and retry" />
      <item value="Since we're reusing the compiled plan, we need to update its start time for current run" />
      <item value="// deferClose indicates if the close/destroy should be deferred when the process has been // interrupted, it should be set to true if the compile is called within another method like // runInternal, which defers the close to the called in that method." />
      <item value="compile internal will automatically reset the perf logger" />
      <item value="Command Processor Response" />
      <item value="Response" />
      <item value="Processor" />
      <item value="Internal" />
      <item value="Here we want to encode the error in machine readable way (e.g. JSON) * Ideally, errorCode would always be set to a canonical error defined in ErrorMsg. * In practice that is rarely the case, so the messy logic below tries to tease * out canonical error code if it can. Exclude stack trace from output when * the error is a specific/expected one. * It's written to stdout for backward compatibility (WebHCat consumes it)" />
      <item value="Enables to use re-execution logics" />
      <item value="Let Driver strip comments using sql parser" />
      <item value="// Start the session in a fire-and-forget manner. When the asynchronously initialized parts of // the session are needed, the corresponding getters and other methods will wait as needed" />
      <item value="Compile a new query. Any currently-planned query associated with this Driver is discarded. * Do not reset id for inner queries(index, etc). Task ids are used for task identity check" />
      <item value="Both UDF and UDAF functions can imply order for analytical functions" />
      <item value="Validate the function name" />
      <item value="SHOW FUNCTIONS is deprecated, please use SHOW FUNCTIONS LIKE instead." />
      <item value="Try qualifying with current db name for permanent functions" />
      <item value="First try without qualifiers - would resolve builtin/temp functions" />
      <item value="Missing over clause for function" />
      <item value="Looks up the function name in the registry. If enabled, will attempt to search the metastore * for the function." />
      <item value="Operator argument type mismatch" />
      <item value="Function argument type mismatch" />
      <item value="expression Tree" />
      <item value="Generate Resolved Parse tree from syntax tree" />
      <item value="// resultSchema will be null if // (1) cbo is disabled; // (2) or cbo is enabled with AST return path (whether succeeded or not, // resultSchema will be re-initialized) // It will only be not null if cbo is enabled with new return path and it // succeeds." />
      <item value="Set the semijoin hints in parse context" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="345" />
        <entry key="ENGLISH" value="346" />
        <entry key="DUTCH" value="2" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>