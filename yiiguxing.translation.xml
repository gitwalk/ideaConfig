<application>
  <component name="AppStorage">
    <histories>
      <item value="projections" />
      <item value="a number of projections" />
      <item value="Apply a number of projections to every input row, hence we will get multiple output rows for * an input row." />
      <item value="drop Duplicates" />
      <item value="A logical plan for `dropDuplicates`" />
      <item value="A relation with one row. This is used in &quot;SELECT ...&quot; without a from clause." />
      <item value="Returns a new logical plan that dedups input rows." />
      <item value="dedups" />
      <item value="Sample" />
      <item value="Sample the dataset" />
      <item value="Aliased subquery" />
      <item value="which" />
      <item value="Expand" />
      <item value="Factory for constructing new `Union` nodes." />
      <item value="Set Operation" />
      <item value="Append data to an existing table" />
      <item value="Aggregate" />
      <item value="Qualifier for the attributes of generator(UDTF)" />
      <item value="when true, each input row will be output at least once, even if the output of the * given `generator` is empty" />
      <item value="similar" />
      <item value="Applies" />
      <item value="This node is inserted at the top of a subquery when it is optimized. This makes sure we can * recognize a subquery as such, and it allows us to write subquery aware transformations." />
      <item value="A class representing a Json {@code null} value. *" />
      <item value="The output schema of the Generator" />
      <item value="new" />
      <item value="java" />
      <item value="The SubqueryAlias node keeps track of the qualifier using the information in this structure" />
      <item value="Model Constants" />
      <item value="a" />
      <item value="aggregate Expressions" />
      <item value="type Hint Field Name" />
      <item value="Aggregation" />
      <item value="Projection" />
      <item value="if the specified text is not valid JSON" />
      <item value="this function creates tables in a way that is hive dependent, therefore hive must be enabled for this to work" />
      <item value="When harvest method is called with an empty data frame&quot; should &quot;return a data lineage with one node." />
      <item value="request Compression Supported" />
      <item value="attribute Converter" />
      <item value="create Operation Builders Recursively" />
      <item value="This is implemented as an" />
      <item value="explicitly" />
      <item value="Metrics" />
      <item value="write Node Builder" />
      <item value="executed Plan Opt" />
      <item value="maybe Event Handler Constructor" />
      <item value="Spline Query Execution Listener" />
      <item value="Dispatcher" />
      <item value="qualifier" />
      <item value="HDFS Path Qualifier" />
      <item value="Spline Short Type Hints" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="509" />
        <entry key="ENGLISH" value="510" />
        <entry key="FRENCH" value="1" />
        <entry key="DUTCH" value="6" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>