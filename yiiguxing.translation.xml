<application>
  <component name="AppStorage">
    <histories>
      <item value="Exception thrown when attempting to execute an authorization action when a successful * authentication hasn't yet occurred. * * &lt;p&gt;Authorizations can only be performed after a successful * authentication because authorization data (roles, permissions, etc) must always be associated * with a known identity. Such a known identity can only be obtained upon a successful log-in. * * @since 0.1" />
      <item value="Applies distortion by adding shadow to the text and also two noises. * * @param baseImage the base image * @return the distorted image" />
      <item value="Single Partition" />
      <item value="Zone" />
      <item value="Factor" />
      <item value="Default Bean Validation group. * &lt;p&gt; * Unless a list of groups is explicitly defined: * &lt;ul&gt; * &lt;li&gt;constraints belong to the {@code Default} group&lt;/li&gt; * &lt;li&gt;validation applies to the {@code Default} group&lt;/li&gt; * &lt;/ul&gt; * Most structural constraints should belong to the default group. * * @author Emmanuel Bernard" />
      <item value="Failed to convert value of type 'java.lang.String' to required type 'java.lang.Integer'" />
      <item value="fail" />
      <item value="catalina.home" />
      <item value="cannot assign instance of java.lang.invoke.SerializedLambda to field org.apache.spark.api.java.JavaPairRDD$$anonfun$toScalaFunction$1.fun$1 of type org.apache.spark.api.java.function.Function in instance of org.apache.spark.api.java.JavaPairRDD$$anonfun$toScalaFunction$1" />
      <item value="Lost task 0.0 in stage 1.0 (TID 1, slave4.hadoop, executor 1): java.lang.ClassCastException: cannot assign instance of java.lang.invoke.SerializedLambda to field org.apache.spark.api.java.JavaPairRDD$$anonfun$toScalaFunction$1.fun$1 of type org.apache.spark.api.java.function.Function in instance of org.apache.spark.api.java.JavaPairRDD$$anonfun$toScalaFunction$1" />
      <item value="Service 'sparkDriver' failed after 16 retries (on a random free port)! Consider explicitly setting the appropriate binding address for the service 'sparkDriver' (for example spark.driver.bindAddress for SparkDriver) to the correct binding address." />
      <item value="Validates parameters and return values of methods and constructors. * Implementations of this interface must be thread-safe." />
      <item value="Executable" />
      <item value="/** * Returns the fully-qualified name of the declaring type. This is * equivalent to calling getDeclaringType().getName(), but caches * the result for greater efficiency. */" />
      <item value="&lt;p&gt;Returns a &lt;code&gt;java.lang.Class&lt;/code&gt; object representing the class, * interface, or aspect that declared this member. For intra-member * declarations, this will be the type on which the member is declared, * not the type where the declaration is lexically written. Use * &lt;code&gt;SourceLocation.getWithinType()&lt;/code&gt; to get the type in * which the declaration occurs lexically.&lt;/p&gt; * &lt;p&gt;For consistency with &lt;code&gt;java.lang.reflect.Member&lt;/code&gt;, this * method should have been named &lt;code&gt;getDeclaringClass()&lt;/code&gt;.&lt;/p&gt; *" />
      <item value="encapsulates" />
      <item value="Returns an object that encapsulates the static parts of this join point. */" />
      <item value="arguments" />
      <item value="Returns the signature at the join point." />
      <item value="When compiling without debug info, or when interpreting pointcuts at runtime, * the names of any arguments used in the advice declaration are not available. * Under these circumstances only, it is necessary to provide the arg names in * the annotation - these MUST duplicate the names used in the annotated method. * Format is a simple comma-separated list." />
      <item value="The pointcut expression where to bind the advice" />
      <item value="** * Specify one or more validation groups to apply to the validation step * kicked off by this annotation. * &lt;p&gt;JSR-303 defines validation groups as custom annotations which an application declares * for the sole purpose of using them as type-safe group arguments, as implemented in * {@link org.springframework.validation.beanvalidation.SpringValidatorAdapter}. * &lt;p&gt;Other {@link org.springframework.validation.SmartValidator} implementations may * support class arguments in other ways as well. */" />
      <item value="* Construct a new ReflectiveMethodInvocation with the given arguments. * @param proxy the proxy object that the invocation was made on * @param target the target object to invoke * @param method the method to invoke * @param arguments the arguments to invoke the method with * @param targetClass the target class, for MethodMatcher invocations * @param interceptorsAndDynamicMethodMatchers interceptors that should be applied, * along with any InterceptorAndDynamicMethodMatchers that need evaluation at runtime. * MethodMatchers included in this struct must already have been found to have matched * as far as was possibly statically. Passing an array might be about 10% faster, * but would complicate the code. And it would work only for static pointcuts. */" />
      <item value="* General purpose AOP callback. Used when the target is dynamic or when the * proxy is not frozen." />
      <item value="Binder that allows for setting property values onto a target object, * including support for validation and binding result analysis. * The binding process can be customized through specifying allowed fields, * required fields, custom editors, etc. * * &lt;p&gt;Note that there are potential security implications in failing to set an array * of allowed fields. In the case of HTTP form POST data for example, malicious clients * can attempt to subvert an application by supplying values for fields or properties * that do not exist on the form. In some cases this could lead to illegal data being * set on command objects &lt;i&gt;or their nested objects&lt;/i&gt;. For this reason, it is * &lt;b&gt;highly recommended to specify the {@link #setAllowedFields allowedFields} property&lt;/b&gt; * on the DataBinder. * * &lt;p&gt;The binding results can be examined via the {@link BindingResult} interface, * extending the {@link Errors} interface: see the {@link #getBindingResult()} method. * Missing fields and property access exceptions will be converted to {@link FieldError FieldErrors}, * collected in the Errors instance, using the following error codes: * * &lt;ul&gt; * &lt;li&gt;Missing field error: &quot;required&quot; * &lt;li&gt;Type mismatch error: &quot;typeMismatch&quot; * &lt;li&gt;Method invocation error: &quot;methodInvocation&quot; * &lt;/ul&gt; * * &lt;p&gt;By default, binding errors get resolved through the {@link BindingErrorProcessor} * strategy, processing for missing fields and property access exceptions: see the * {@link #setBindingErrorProcessor} method. You can override the default strategy * if needed, for example to generate different error codes. * * &lt;p&gt;Custom validation errors can be added afterwards. You will typically want to resolve * such error codes into proper user-visible error messages; this can be achieved through * resolving each error via a {@link org.springframework.context.MessageSource}, which is * able to resolve an {@link ObjectError}/{@link FieldError} through its * {@link org.springframework.context.MessageSource#getMessage(org.springframework.context.MessageSourceResolvable, java.util.Locale)} * method. The list of message codes can be customized through the {@link MessageCodesResolver} * strategy: see the {@link #setMessageCodesResolver} method. {@link DefaultMessageCodesResolver}'s * javadoc states details on the default resolution rules. * * &lt;p&gt;This generic data binder can be used in any kind of environment. *" />
      <item value="* Thrown when binding errors are considered fatal. Implements the * {@link BindingResult} interface (and its super-interface {@link Errors}) * to allow for the direct analysis of binding errors. * * &lt;p&gt;As of Spring 2.0, this is a special-purpose class. Normally, * application code will work with the {@link BindingResult} interface, * or with a {@link DataBinder} that in turn exposes a BindingResult via * {@link org.springframework.validation.DataBinder#getBindingResult()}. * * @author Rod Johnson * @author Juergen Hoeller * @author Rob Harrop * @see BindingResult * @see DataBinder#getBindingResult() * @see DataBinder#close()" />
      <item value="/** * Class constructor. * @param annotationNotRequired if &quot;true&quot;, non-simple method arguments and * return values are considered model attributes with or without a * {@code @ModelAttribute} annotation */" />
      <item value="/** * Resolve the argument from the model or if not found instantiate it with * its default if it is available. The model attribute is then populated * with request values via data binding and optionally validated * if {@code @java.validation.Valid} is present on the argument. * @throws BindException if data binding and validation result in an error * and the next method parameter is not of type {@link Errors} * @throws Exception if WebDataBinder initialization fails */" />
      <item value="java.lang.IllegalStateException: An Errors/BindingResult argument is expected to be declared immediately after the model attribut" />
      <item value="Formal parameter declaration" />
      <item value="/** * Variant of JSR-303's {@link javax.validation.Valid}, supporting the * specification of validation groups. Designed for convenient use with * Spring's JSR-303 support but not JSR-303 specific. * * &lt;p&gt;Can be used e.g. with Spring MVC handler methods arguments. * Supported through {@link org.springframework.validation.SmartValidator}'s * validation hint concept, with validation group classes acting as hint objects. * * &lt;p&gt;Can also be used with method level validation, indicating that a specific * class is supposed to be validated at the method level (acting as a pointcut * for the corresponding validation interceptor), but also optionally specifying * the validation groups for method-level validation in the annotated class. * Applying this annotation at the method level allows for overriding the * validation groups for a specific method but does not serve as a pointcut; * a class-level annotation is nevertheless necessary to trigger method validation * for a specific bean to begin with. Can also be used as a meta-annotation on a * custom stereotype annotation or a custom group-specific validated annotation. *" />
      <item value="/** * Specify one or more validation groups to apply to the validation step * kicked off by this annotation. * &lt;p&gt;JSR-303 defines validation groups as custom annotations which an application declares * for the sole purpose of using them as type-safe group arguments, as implemented in * {@link org.springframework.validation.beanvalidation.SpringValidatorAdapter}. * &lt;p&gt;Other {@link org.springframework.validation.SmartValidator} implementations may * support class arguments in other ways as well. */" />
      <item value="* Specify one or more validation groups to apply to the validation step * kicked off by this annotation. * &lt;p&gt;JSR-303 defines validation groups as custom annotations which an application declares * for the sole purpose of using them as type-safe group arguments, as implemented in * {@link org.springframework.validation.beanvalidation.SpringValidatorAdapter}. * &lt;p&gt;Other {@link org.springframework.validation.SmartValidator} implementations may * support class arguments in other ways as well. */" />
      <item value="Column 'paper_id' in field list is ambiguous" />
      <item value="* Flushes this output stream and forces any buffered output bytes * to be written out. The general contract of &lt;code&gt;flush&lt;/code&gt; is * that calling it is an indication that, if any bytes previously * written have been buffered by the implementation of the output * stream, such bytes should immediately be written to their * intended destination. * &lt;p&gt; * If the intended destination of this stream is an abstraction provided by * the underlying operating system, for example a file, then flushing the * stream guarantees only that bytes previously written to the stream are * passed to the operating system for writing; it does not guarantee that * they are actually written to a physical device such as a disk drive. * &lt;p&gt;" />
      <item value="Set the value for the scoped attribute of the given name, * replacing an existing value (if any)." />
      <item value="the name of the attribute" />
      <item value="/** * The class {@code Exception} and its subclasses are a form of * {@code Throwable} that indicates conditions that a reasonable * application might want to catch. * * &lt;p&gt;The class {@code Exception} and any subclasses that are not also * subclasses of {@link RuntimeException} are &lt;em&gt;checked * exceptions&lt;/em&gt;. Checked exceptions need to be declared in a * method or constructor's {@code throws} clause if they can be thrown * by the execution of the method or constructor and propagate outside * the method or constructor boundary. * * @author Frank Yellin * @see java.lang.Error * @jls 11.2 Compile-Time Checking of Exceptions * @since JDK1.0" />
      <item value="* Returns a &lt;code&gt;DirectColorModel&lt;/code&gt; that describes the default * format for integer RGB values used in many of the methods in the * AWT image interfaces for the convenience of the programmer. * The color space is the default {@link ColorSpace}, sRGB. * The format for the RGB values is an integer with 8 bits * each of alpha, red, green, and blue color components ordered * correspondingly from the most significant byte to the least * significant byte, as in: 0xAARRGGBB. Color components are * not premultiplied by the alpha component. This format does not * necessarily represent the native or the most efficient * &lt;code&gt;ColorModel&lt;/code&gt; for a particular device or for all images. * It is merely used as a common color model format. * @return a &lt;code&gt;DirectColorModel&lt;/code&gt;object describing default * RGB values. */" />
      <item value="* Represents image data that contains or might contain arbitrary * alpha values between and including 0.0 and 1.0." />
      <item value="Represents image data that is guaranteed to be completely opaque, * meaning that all pixels have an alpha value of 1.0." />
      <item value="The {@code RenderingHints} class defines and manages collections of * keys and associated values which allow an application to provide input * into the choice of algorithms used by other classes which perform * rendering and image manipulation services. * The {@link java.awt.Graphics2D} class, and classes that implement * {@link java.awt.image.BufferedImageOp} and * {@link java.awt.image.RasterOp} all provide methods to get and * possibly to set individual or groups of {@code RenderingHints} * keys and their associated values. * When those implementations perform any rendering or image manipulation * operations they should examine the values of any {@code RenderingHints} * that were requested by the caller and tailor the algorithms used * accordingly and to the best of their ability. * &lt;p&gt; * Note that since these keys and values are &lt;i&gt;hints&lt;/i&gt;, there is * no requirement that a given implementation supports all possible * choices indicated below or that it can respond to requests to * modify its choice of algorithm. * The values of the various hint keys may also interact such that * while all variants of a given key are supported in one situation, * the implementation may be more restricted when the values associated * with other keys are modified. * For example, some implementations may be able to provide several * types of dithering when the antialiasing hint is turned off, but * have little control over dithering when antialiasing is on. * The full set of supported keys and hints may also vary by destination * since runtimes may use different underlying modules to render to * the screen, or to {@link java.awt.image.BufferedImage} objects, * or while printing. * &lt;p&gt; * Implementations are free to ignore the hints completely, but should * try to use an implementation algorithm that is as close as possible * to the request. * If an implementation supports a given algorithm when any value is used * for an associated hint key, then minimally it must do so when the * value for that key is the exact value that specifies the algorithm. * &lt;p&gt; * The keys used to control the hints are all special values that * subclass the associated {@link RenderingHints.Key} class. * Many common hints are expressed below as static constants in this * class, but the list is not meant to be exhaustive. * Other hints may be created by other packages by defining new objects * which subclass the {@code Key} class and defining the associated values. */" />
      <item value="Returns a &lt;code&gt;BufferedImage&lt;/code&gt; that supports the specified * transparency and has a data layout and color model * compatible with this &lt;code&gt;GraphicsConfiguration&lt;/code&gt;. This * method has nothing to do with memory-mapping * a device. The returned &lt;code&gt;BufferedImage&lt;/code&gt; has a layout and * color model that can be optimally blitted to a device * with this &lt;code&gt;GraphicsConfiguration&lt;/code&gt;." />
      <item value="* Graphics objects which are provided as arguments to the * &lt;code&gt;paint&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt; methods * of components are automatically released by the system when * those methods return. For efficiency, programmers should * call &lt;code&gt;dispose&lt;/code&gt; when finished using * a &lt;code&gt;Graphics&lt;/code&gt; object only if it was created * directly from a component or another &lt;code&gt;Graphics&lt;/code&gt;" />
      <item value="* When a Java program runs, a large number of &lt;code&gt;Graphics&lt;/code&gt; * objects can be created within a short time frame. * Although the finalization process of the garbage collector * also disposes of the same system resources, it is preferable * to manually free the associated resources by calling this * method rather than to rely on a finalization process which * may not run to completion for a long period of time." />
      <item value="Disposes of this graphics context and releases * any system resources that it is using." />
      <item value="* Color rendering hint value -- perform the color conversion * calculations with the highest accuracy and visual quality. * @see #KEY_COLOR_RENDERING" />
      <item value="Antialiasing hint value -- rendering is done without antialiasing. * @see #KEY_ANTIALIASING" />
      <item value="Constructs a new object with the specified key/value pair" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="107" />
        <entry key="ENGLISH" value="108" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>