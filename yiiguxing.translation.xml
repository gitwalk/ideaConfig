<application>
  <component name="AppStorage">
    <histories>
      <item value="Cancelled" />
      <item value="Paid" />
      <item value="INVALID FOR AFFILIATE FLAG" />
      <item value="Subject Matter Term Detail" />
      <item value="maybe Event Handler Constructor" />
      <item value="Spline Query Execution Listener" />
      <item value="Dispatcher" />
      <item value="qualifier" />
      <item value="HDFS Path Qualifier" />
      <item value="Spline Short Type Hints" />
      <item value="Harvester Json Ser De" />
      <item value="Default Ignored Write Detection Strategy" />
      <item value="User Extra Metadata Provider" />
      <item value="exception" />
      <item value="extra" />
      <item value="Harvester" />
      <item value="dispatcher" />
      <item value="Expression" />
      <item value="Turbine Run Data" />
      <item value="Identify and stop the process that's listening on port 8761 or configure this application to listen on another port." />
      <item value="destination" />
      <item value="A map from a final select operator id to the select operator * and the corresponding target table in case an insert into query." />
      <item value="A map from a final select operator id to the select operator * and the corresponding target table in case an insert into query" />
      <item value="A map from operator to the conditions strings." />
      <item value="ALLSCOPE EXCEPT COLUMN" />
      <item value="Generate normalized name for a given target column" />
      <item value="Unable to fetch table" />
      <item value="Write the status of tables to a file." />
      <item value="Find whether the current query is a logical explain query" />
      <item value="Either list of columns or a custom serializer should be specified" />
      <item value="gen File Sink Plan" />
      <item value="Go over all the destination tables" />
      <item value="Constructs a standard group by plan if: // There is no other subquery with the same group by/distinct keys or // (There are no aggregations in a representative query for the group and // There is no group by in that representative query) or // The data is skewed or // The conf variable used to control combining group bys into a single reducer is false" />
      <item value="There is no other subquery with the same group by/distinct keys or" />
      <item value="Constructs a standard group by plan if:" />
      <item value="Iterate over each group of subqueries with the same group by/distinct keys" />
      <item value="If we can put multiple group bys in a single reducer, determine suitable groups of // expressions, otherwise treat all the expressions as a single group" />
      <item value="partitioned table functions" />
      <item value="After processing subqueries and source tables, process" />
      <item value="Recurse over all the source tables" />
      <item value="Recurse over the subqueries to fill the subquery part of the plan" />
      <item value="First generate all the opInfos for the elements in the from clause" />
      <item value="then" />
      <item value="Check for dynamic partitions" />
      <item value="Method invoked when the given thread terminates due to the * given uncaught exception. * &lt;p&gt;Any exception thrown by this method will be ignored by the * Java Virtual Machine. * @param t the thread * @param e the exception */" />
      <item value="When init(true) combine with genResolvedParseTree, it will generate Resolved Parse tree from syntax tree //ReadEntity created under these conditions should be all relevant to the syntax tree even the ones without parents //set mergeIsDirect to true here" />
      <item value="Implementation of the semantic analyzer. It generates the query plan. * There are other specific semantic analyzers for some hive operations such as * DDLSemanticAnalyzer for ddl operations." />
      <item value="cascade only occurs with partitioned table" />
      <item value="Generate normalized name for a given target column." />
      <item value="A mapping from a tableName to a table object in metastore." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="472" />
        <entry key="ENGLISH" value="473" />
        <entry key="FRENCH" value="1" />
        <entry key="DUTCH" value="6" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>