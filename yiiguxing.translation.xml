<application>
  <component name="AppStorage">
    <histories>
      <item value="/** * Sorts the specified range of the array using the given * workspace array slice if possible for merging * * @param a the array to be sorted * @param left the index of the first element, inclusive, to be sorted * @param right the index of the last element, inclusive, to be sorted * @param work a workspace array (slice) * @param workBase origin of usable space in work array * @param workLen usable size of work array */" />
      <item value="* Adapter no-op implementation - does nothing and returns immediately. * * @param session the session that has expired." />
      <item value="/** * Adapter no-op implementation - does nothing and returns immediately. * * @param session the session that has stopped." />
      <item value="Simple adapter implementation of the {@link SessionListener} interface, effectively providing * no-op implementations of all methods. *" />
      <item value="* Retrieves the Session object from the underlying EIS identified by &lt;tt&gt;sessionId&lt;/tt&gt; by delegating to * the {@link #doReadSession(java.io.Serializable)} method. If {@code null} is returned from that method, an * {@link UnknownSessionException} will be thrown. * * @param sessionId the id of the session to retrieve from the EIS. * @return the session identified by &lt;tt&gt;sessionId&lt;/tt&gt; in the EIS. * @throws UnknownSessionException if the id specified does not correspond to any session in the EIS. */" />
      <item value="/** * Get the value of {@code key}. * * @param key must not be {@literal null}. * @return {@literal null} when used in pipeline / transaction. * @see &lt;a href=&quot;http://redis.io/commands/get&quot;&gt;Redis Documentation: GET&lt;/a&gt; */" />
      <item value="/** * Retrieves the session from the EIS uniquely identified by the specified * {@code sessionId}. * * @param sessionId the system-wide unique identifier of the Session object to retrieve from * the EIS. * @return the persisted session in the EIS identified by {@code sessionId}. * @throws UnknownSessionException if there is no EIS record for any session with the * specified {@code sessionId} */" />
      <item value="DEPARTMENT" />
      <item value="/** * Asserts this Subject has the specified role by returning quietly if they do or throwing an * {@link org.apache.shiro.authz.AuthorizationException} if they do not. * * @param roleIdentifier the application-specific role identifier (usually a role id or role name ). * @throws org.apache.shiro.authz.AuthorizationException * if this Subject does not have the role. */" />
      <item value="/** * Returns {@code true} if this Subject has the specified role, {@code false} otherwise. * * @param roleIdentifier the application-specific role identifier (usually a role id or role name). * @return {@code true} if this Subject has the specified role, {@code false} otherwise. */" />
      <item value="get User Distributions" />
      <item value="Exception thrown when attempting to execute an authorization action when a successful * authentication hasn't yet occurred. * * &lt;p&gt;Authorizations can only be performed after a successful * authentication because authorization data (roles, permissions, etc) must always be associated * with a known identity. Such a known identity can only be obtained upon a successful log-in. * * @since 0.1" />
      <item value="Applies distortion by adding shadow to the text and also two noises. * * @param baseImage the base image * @return the distorted image" />
      <item value="Single Partition" />
      <item value="Zone" />
      <item value="Factor" />
      <item value="Default Bean Validation group. * &lt;p&gt; * Unless a list of groups is explicitly defined: * &lt;ul&gt; * &lt;li&gt;constraints belong to the {@code Default} group&lt;/li&gt; * &lt;li&gt;validation applies to the {@code Default} group&lt;/li&gt; * &lt;/ul&gt; * Most structural constraints should belong to the default group. * * @author Emmanuel Bernard" />
      <item value="Failed to convert value of type 'java.lang.String' to required type 'java.lang.Integer'" />
      <item value="fail" />
      <item value="catalina.home" />
      <item value="cannot assign instance of java.lang.invoke.SerializedLambda to field org.apache.spark.api.java.JavaPairRDD$$anonfun$toScalaFunction$1.fun$1 of type org.apache.spark.api.java.function.Function in instance of org.apache.spark.api.java.JavaPairRDD$$anonfun$toScalaFunction$1" />
      <item value="Lost task 0.0 in stage 1.0 (TID 1, slave4.hadoop, executor 1): java.lang.ClassCastException: cannot assign instance of java.lang.invoke.SerializedLambda to field org.apache.spark.api.java.JavaPairRDD$$anonfun$toScalaFunction$1.fun$1 of type org.apache.spark.api.java.function.Function in instance of org.apache.spark.api.java.JavaPairRDD$$anonfun$toScalaFunction$1" />
      <item value="Service 'sparkDriver' failed after 16 retries (on a random free port)! Consider explicitly setting the appropriate binding address for the service 'sparkDriver' (for example spark.driver.bindAddress for SparkDriver) to the correct binding address." />
      <item value="Validates parameters and return values of methods and constructors. * Implementations of this interface must be thread-safe." />
      <item value="Executable" />
      <item value="/** * Returns the fully-qualified name of the declaring type. This is * equivalent to calling getDeclaringType().getName(), but caches * the result for greater efficiency. */" />
      <item value="&lt;p&gt;Returns a &lt;code&gt;java.lang.Class&lt;/code&gt; object representing the class, * interface, or aspect that declared this member. For intra-member * declarations, this will be the type on which the member is declared, * not the type where the declaration is lexically written. Use * &lt;code&gt;SourceLocation.getWithinType()&lt;/code&gt; to get the type in * which the declaration occurs lexically.&lt;/p&gt; * &lt;p&gt;For consistency with &lt;code&gt;java.lang.reflect.Member&lt;/code&gt;, this * method should have been named &lt;code&gt;getDeclaringClass()&lt;/code&gt;.&lt;/p&gt; *" />
      <item value="encapsulates" />
      <item value="Returns an object that encapsulates the static parts of this join point. */" />
      <item value="arguments" />
      <item value="Returns the signature at the join point." />
      <item value="When compiling without debug info, or when interpreting pointcuts at runtime, * the names of any arguments used in the advice declaration are not available. * Under these circumstances only, it is necessary to provide the arg names in * the annotation - these MUST duplicate the names used in the annotated method. * Format is a simple comma-separated list." />
      <item value="The pointcut expression where to bind the advice" />
      <item value="** * Specify one or more validation groups to apply to the validation step * kicked off by this annotation. * &lt;p&gt;JSR-303 defines validation groups as custom annotations which an application declares * for the sole purpose of using them as type-safe group arguments, as implemented in * {@link org.springframework.validation.beanvalidation.SpringValidatorAdapter}. * &lt;p&gt;Other {@link org.springframework.validation.SmartValidator} implementations may * support class arguments in other ways as well. */" />
      <item value="* Construct a new ReflectiveMethodInvocation with the given arguments. * @param proxy the proxy object that the invocation was made on * @param target the target object to invoke * @param method the method to invoke * @param arguments the arguments to invoke the method with * @param targetClass the target class, for MethodMatcher invocations * @param interceptorsAndDynamicMethodMatchers interceptors that should be applied, * along with any InterceptorAndDynamicMethodMatchers that need evaluation at runtime. * MethodMatchers included in this struct must already have been found to have matched * as far as was possibly statically. Passing an array might be about 10% faster, * but would complicate the code. And it would work only for static pointcuts. */" />
      <item value="* General purpose AOP callback. Used when the target is dynamic or when the * proxy is not frozen." />
      <item value="Binder that allows for setting property values onto a target object, * including support for validation and binding result analysis. * The binding process can be customized through specifying allowed fields, * required fields, custom editors, etc. * * &lt;p&gt;Note that there are potential security implications in failing to set an array * of allowed fields. In the case of HTTP form POST data for example, malicious clients * can attempt to subvert an application by supplying values for fields or properties * that do not exist on the form. In some cases this could lead to illegal data being * set on command objects &lt;i&gt;or their nested objects&lt;/i&gt;. For this reason, it is * &lt;b&gt;highly recommended to specify the {@link #setAllowedFields allowedFields} property&lt;/b&gt; * on the DataBinder. * * &lt;p&gt;The binding results can be examined via the {@link BindingResult} interface, * extending the {@link Errors} interface: see the {@link #getBindingResult()} method. * Missing fields and property access exceptions will be converted to {@link FieldError FieldErrors}, * collected in the Errors instance, using the following error codes: * * &lt;ul&gt; * &lt;li&gt;Missing field error: &quot;required&quot; * &lt;li&gt;Type mismatch error: &quot;typeMismatch&quot; * &lt;li&gt;Method invocation error: &quot;methodInvocation&quot; * &lt;/ul&gt; * * &lt;p&gt;By default, binding errors get resolved through the {@link BindingErrorProcessor} * strategy, processing for missing fields and property access exceptions: see the * {@link #setBindingErrorProcessor} method. You can override the default strategy * if needed, for example to generate different error codes. * * &lt;p&gt;Custom validation errors can be added afterwards. You will typically want to resolve * such error codes into proper user-visible error messages; this can be achieved through * resolving each error via a {@link org.springframework.context.MessageSource}, which is * able to resolve an {@link ObjectError}/{@link FieldError} through its * {@link org.springframework.context.MessageSource#getMessage(org.springframework.context.MessageSourceResolvable, java.util.Locale)} * method. The list of message codes can be customized through the {@link MessageCodesResolver} * strategy: see the {@link #setMessageCodesResolver} method. {@link DefaultMessageCodesResolver}'s * javadoc states details on the default resolution rules. * * &lt;p&gt;This generic data binder can be used in any kind of environment. *" />
      <item value="* Thrown when binding errors are considered fatal. Implements the * {@link BindingResult} interface (and its super-interface {@link Errors}) * to allow for the direct analysis of binding errors. * * &lt;p&gt;As of Spring 2.0, this is a special-purpose class. Normally, * application code will work with the {@link BindingResult} interface, * or with a {@link DataBinder} that in turn exposes a BindingResult via * {@link org.springframework.validation.DataBinder#getBindingResult()}. * * @author Rod Johnson * @author Juergen Hoeller * @author Rob Harrop * @see BindingResult * @see DataBinder#getBindingResult() * @see DataBinder#close()" />
      <item value="/** * Class constructor. * @param annotationNotRequired if &quot;true&quot;, non-simple method arguments and * return values are considered model attributes with or without a * {@code @ModelAttribute} annotation */" />
      <item value="/** * Resolve the argument from the model or if not found instantiate it with * its default if it is available. The model attribute is then populated * with request values via data binding and optionally validated * if {@code @java.validation.Valid} is present on the argument. * @throws BindException if data binding and validation result in an error * and the next method parameter is not of type {@link Errors} * @throws Exception if WebDataBinder initialization fails */" />
      <item value="java.lang.IllegalStateException: An Errors/BindingResult argument is expected to be declared immediately after the model attribut" />
      <item value="Formal parameter declaration" />
      <item value="/** * Variant of JSR-303's {@link javax.validation.Valid}, supporting the * specification of validation groups. Designed for convenient use with * Spring's JSR-303 support but not JSR-303 specific. * * &lt;p&gt;Can be used e.g. with Spring MVC handler methods arguments. * Supported through {@link org.springframework.validation.SmartValidator}'s * validation hint concept, with validation group classes acting as hint objects. * * &lt;p&gt;Can also be used with method level validation, indicating that a specific * class is supposed to be validated at the method level (acting as a pointcut * for the corresponding validation interceptor), but also optionally specifying * the validation groups for method-level validation in the annotated class. * Applying this annotation at the method level allows for overriding the * validation groups for a specific method but does not serve as a pointcut; * a class-level annotation is nevertheless necessary to trigger method validation * for a specific bean to begin with. Can also be used as a meta-annotation on a * custom stereotype annotation or a custom group-specific validated annotation. *" />
      <item value="/** * Specify one or more validation groups to apply to the validation step * kicked off by this annotation. * &lt;p&gt;JSR-303 defines validation groups as custom annotations which an application declares * for the sole purpose of using them as type-safe group arguments, as implemented in * {@link org.springframework.validation.beanvalidation.SpringValidatorAdapter}. * &lt;p&gt;Other {@link org.springframework.validation.SmartValidator} implementations may * support class arguments in other ways as well. */" />
      <item value="* Specify one or more validation groups to apply to the validation step * kicked off by this annotation. * &lt;p&gt;JSR-303 defines validation groups as custom annotations which an application declares * for the sole purpose of using them as type-safe group arguments, as implemented in * {@link org.springframework.validation.beanvalidation.SpringValidatorAdapter}. * &lt;p&gt;Other {@link org.springframework.validation.SmartValidator} implementations may * support class arguments in other ways as well. */" />
      <item value="Column 'paper_id' in field list is ambiguous" />
      <item value="* Flushes this output stream and forces any buffered output bytes * to be written out. The general contract of &lt;code&gt;flush&lt;/code&gt; is * that calling it is an indication that, if any bytes previously * written have been buffered by the implementation of the output * stream, such bytes should immediately be written to their * intended destination. * &lt;p&gt; * If the intended destination of this stream is an abstraction provided by * the underlying operating system, for example a file, then flushing the * stream guarantees only that bytes previously written to the stream are * passed to the operating system for writing; it does not guarantee that * they are actually written to a physical device such as a disk drive. * &lt;p&gt;" />
      <item value="Set the value for the scoped attribute of the given name, * replacing an existing value (if any)." />
      <item value="the name of the attribute" />
      <item value="/** * The class {@code Exception} and its subclasses are a form of * {@code Throwable} that indicates conditions that a reasonable * application might want to catch. * * &lt;p&gt;The class {@code Exception} and any subclasses that are not also * subclasses of {@link RuntimeException} are &lt;em&gt;checked * exceptions&lt;/em&gt;. Checked exceptions need to be declared in a * method or constructor's {@code throws} clause if they can be thrown * by the execution of the method or constructor and propagate outside * the method or constructor boundary. * * @author Frank Yellin * @see java.lang.Error * @jls 11.2 Compile-Time Checking of Exceptions * @since JDK1.0" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="118" />
        <entry key="ENGLISH" value="119" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>