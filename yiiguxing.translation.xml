<application>
  <component name="AppStorage">
    <histories>
      <item value="Summarize" />
      <item value="resolution" />
      <item value="Frag" />
      <item value="Peak" />
      <item value="Scene Config" />
      <item value="clean Embedded Dynamic Watermark Info" />
      <item value="Material" />
      <item value="Matching" />
      <item value="banner" />
      <item value="aliwood" />
      <item value="http://nhcil-open.alibaba-inc.com.vipserver/aliwood/genvideo/async" />
      <item value="Video Meta Analyse Data Handler" />
      <item value="Image None Operate Data Handler" />
      <item value="image Matting With Score" />
      <item value="Image Matting Quality Data Handler" />
      <item value="Image Matting Data Handler" />
      <item value="Image Compose" />
      <item value="matting" />
      <item value="Image Material Item M" />
      <item value="Tair Client Interface" />
      <item value="Image Compose Timer" />
      <item value="Image Timer" />
      <item value="Clean Direct Memory Timer" />
      <item value="Constants" />
      <item value="Diamond" />
      <item value="I Cracker Services Locator" />
      <item value="Matting" />
      <item value="Image Erase Watermark Data Handler" />
      <item value="Image Compose Data Handler" />
      <item value="Image Border Remove Data Handler" />
      <item value="Water Mask" />
      <item value="Water" />
      <item value="Erase" />
      <item value="Erase Water Mask Validator" />
      <item value="Validator Dispatcher" />
      <item value="validate" />
      <item value="* Applies a [[Generator]] to a stream of input rows, combining the * output of each into a new stream of rows. This operation is similar to a `flatMap` in functional * programming with one important additional feature, which allows the input rows to be joined with * their output." />
      <item value="this parameter starts as Nil and gets filled by the Optimizer. * It's used as an optimization for omitting data generation that will * be discarded next by a projection. * A common use case is when we explode(array(..)) and are interested * only in the exploded data and not in the original array. before this * optimization the array got duplicated for each of its elements, * causing O(n^^2) memory consumption. (see [SPARK-21657])" />
      <item value="Creates a new row for each element in the given array or map column" />
      <item value="when true, each input row will be output at least once, even if the output of the * given `generator` is empty." />
      <item value="Union can only be performed on tables with the compatible column types" />
      <item value="projections" />
      <item value="a number of projections" />
      <item value="Apply a number of projections to every input row, hence we will get multiple output rows for * an input row." />
      <item value="drop Duplicates" />
      <item value="A logical plan for `dropDuplicates`" />
      <item value="A relation with one row. This is used in &quot;SELECT ...&quot; without a from clause." />
      <item value="Returns a new logical plan that dedups input rows." />
      <item value="dedups" />
      <item value="Sample" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="551" />
        <entry key="ENGLISH" value="552" />
        <entry key="DANISH" value="1" />
        <entry key="GERMAN" value="1" />
        <entry key="FRENCH" value="1" />
        <entry key="FILIPINO" value="1" />
        <entry key="DUTCH" value="6" />
        <entry key="NORWEGIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>