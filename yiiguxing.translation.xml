<application>
  <component name="AppStorage">
    <histories>
      <item value="matting" />
      <item value="Image Material Item M" />
      <item value="Tair Client Interface" />
      <item value="Image Compose Timer" />
      <item value="Image Timer" />
      <item value="Clean Direct Memory Timer" />
      <item value="Constants" />
      <item value="Diamond" />
      <item value="I Cracker Services Locator" />
      <item value="Matting" />
      <item value="Image Erase Watermark Data Handler" />
      <item value="Image Compose Data Handler" />
      <item value="Image Border Remove Data Handler" />
      <item value="Water Mask" />
      <item value="Water" />
      <item value="Erase" />
      <item value="Erase Water Mask Validator" />
      <item value="Validator Dispatcher" />
      <item value="validate" />
      <item value="* Applies a [[Generator]] to a stream of input rows, combining the * output of each into a new stream of rows. This operation is similar to a `flatMap` in functional * programming with one important additional feature, which allows the input rows to be joined with * their output." />
      <item value="this parameter starts as Nil and gets filled by the Optimizer. * It's used as an optimization for omitting data generation that will * be discarded next by a projection. * A common use case is when we explode(array(..)) and are interested * only in the exploded data and not in the original array. before this * optimization the array got duplicated for each of its elements, * causing O(n^^2) memory consumption. (see [SPARK-21657])" />
      <item value="Creates a new row for each element in the given array or map column" />
      <item value="when true, each input row will be output at least once, even if the output of the * given `generator` is empty." />
      <item value="Union can only be performed on tables with the compatible column types" />
      <item value="projections" />
      <item value="a number of projections" />
      <item value="Apply a number of projections to every input row, hence we will get multiple output rows for * an input row." />
      <item value="drop Duplicates" />
      <item value="A logical plan for `dropDuplicates`" />
      <item value="A relation with one row. This is used in &quot;SELECT ...&quot; without a from clause." />
      <item value="Returns a new logical plan that dedups input rows." />
      <item value="dedups" />
      <item value="Sample" />
      <item value="Sample the dataset" />
      <item value="Aliased subquery" />
      <item value="which" />
      <item value="Expand" />
      <item value="Factory for constructing new `Union` nodes." />
      <item value="Set Operation" />
      <item value="Append data to an existing table" />
      <item value="Aggregate" />
      <item value="Qualifier for the attributes of generator(UDTF)" />
      <item value="when true, each input row will be output at least once, even if the output of the * given `generator` is empty" />
      <item value="similar" />
      <item value="Applies" />
      <item value="This node is inserted at the top of a subquery when it is optimized. This makes sure we can * recognize a subquery as such, and it allows us to write subquery aware transformations." />
      <item value="A class representing a Json {@code null} value. *" />
      <item value="The output schema of the Generator" />
      <item value="new" />
      <item value="java" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="535" />
        <entry key="ENGLISH" value="536" />
        <entry key="DANISH" value="1" />
        <entry key="FRENCH" value="1" />
        <entry key="DUTCH" value="6" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>