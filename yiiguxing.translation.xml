<application>
  <component name="AppStorage">
    <histories>
      <item value="* The compiler compiles the command, by creating a QueryPlan from a String command. * Also opens a transaction if necessary." />
      <item value="// The dispatcher fires the processor corresponding to the closest matching // rule and passes the context along" />
      <item value="// create a walker which walks the tree in a DFS manner while maintaining // the operator stack. The dispatcher // generates the plan from the operator tree" />
      <item value="Hive sends with both old and new table names in the outputs which is weird. So skipping that with the below check" />
      <item value="change the location of position alias process here" />
      <item value="Get Optimized AST for the given QB tree in the semAnalyzer" />
      <item value="fetch all the hints in qb" />
      <item value="Fix up the query for materialization rebuild" />
      <item value="Fix up the query for insert/ctas/materialized views" />
      <item value="Convert Plan to AST" />
      <item value="* Tries to optimize FROM clause of multi-insert. No attempt to optimize insert clauses of the query. * Returns true if rewriting is successful, false otherwise." />
      <item value="Regen OP plan from optimized AST" />
      <item value="Include cost as provided by Calcite" />
      <item value="Recurse over the subqueries to fill the subquery part of the plan" />
      <item value="First generate all the opInfos for the elements in the from clause" />
      <item value="Generate Parse Context for Optimizer &amp; Physical compiler" />
      <item value="Invoke all the transformations one-by-one, and alter the query plan" />
      <item value="transformations" />
      <item value="Retrieve information about cache usage for the query." />
      <item value="validate the plan" />
      <item value="Determines transaction type based on query AST" />
      <item value="Determines transaction type based on query AST." />
      <item value="SemanticAnalyzerFactory also sets the hive operation in query state" />
      <item value="deferClose indicates if the close/destroy should be deferred when the process has been" />
      <item value="Internal" />
      <item value="Set HDFS CallerContext to queryId and reset back to sessionId after the query is done" />
      <item value="local mode" />
      <item value="for shell commands, use unstripped command" />
      <item value="Let Driver strip comments using sql parser" />
      <item value="Flush the print stream, so it doesn't include output from the last command" />
      <item value="Once we are done processing the line, restore the old handler" />
      <item value="we can not use &quot;split&quot; function directly as &quot;;&quot; may be quoted" />
      <item value="Remember all threads that were running at the time we started line processing." />
      <item value="The commands to process" />
      <item value="Processes a line of semicolon separated commands" />
      <item value="use the specified database if specified" />
      <item value="status of the CLI command execution" />
      <item value="Operation processor of the CLI invocation" />
      <item value="Execute the cli work" />
      <item value="optimizer" />
      <item value="Dispatcher to call for each op encountered" />
      <item value="Constructor with keeping all the ancestors in the operator stack during * dispatching." />
      <item value="for a lineage generator with operator tree, 2 levels of current node's * ancestors need to keep in the operator stack." />
      <item value="Each node will be accessed once while it could be dispatched multiple times" />
      <item value="that the node will only get dispatched after all the parents are dispatched" />
      <item value="Starting from the startNodes, add the children whose parents have been // included in the list." />
      <item value="starting point for walking" />
      <item value="Create a list of topop nodes" />
      <item value="The dispatcher fires the processor corresponding to the closest matching rule and passes the context along" />
      <item value="Create the lineage context" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="282" />
        <entry key="ENGLISH" value="283" />
        <entry key="DUTCH" value="2" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>