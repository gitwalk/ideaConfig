<application>
  <component name="AppStorage">
    <histories>
      <item value="Based on the plan outputs, find out the target table name and column names" />
      <item value="Optimizer" />
      <item value="resultSchema will be null if // (1) cbo is disabled; // (2) or cbo is enabled with AST return path (whether succeeded or not, // resultSchema will be re-initialized) // It will only be not null if cbo is enabled with new return path and it // succeeds." />
      <item value="Check query results cache // In the case that row or column masking/filtering was required, we do not support caching. // TODO: Enable caching for queries with masking/filtering" />
      <item value="Generate column access stats if required - wait until column pruning // takes place during optimization" />
      <item value="Generate Parse Context for Optimizer &amp; Physical compiler" />
      <item value="Set the semijoin hints in parse context" />
      <item value="Perform Logical optimization" />
      <item value="if any filters are present in the join tree, push them on top of the // table" />
      <item value="if there is only one destination in Query try to push where predicates * as Join conditions" />
      <item value="initialize FetchTask right here" />
      <item value="Recurse over all the source tables" />
      <item value="Recurse over the subqueries to fill the subquery part of the plan" />
      <item value="Some initial checks for a query to see if we can look this query up in the results cache." />
      <item value="If we use CBO and we may apply masking/filtering policies, we create a copy of the ast. // The reason is that the generation of the operator tree may modify the initial ast, // but if we need to parse for a second time, we would like to parse the unmodified ast" />
      <item value="Check query results cache. // If no masking/filtering required, then we can check the cache now, before // generating the operator tree and going through CBO. // Otherwise we have to wait until after the masking/filtering step" />
      <item value="replace each of the position alias in ORDERBY with the actual column name, // if cbo is enabled, orderby position will be processed in genPlan" />
      <item value="Gen OP Tree from resolved Parse Tree" />
      <item value="fetch all the hints in qb" />
      <item value="If we use CBO and we may apply masking/filtering policies, we create a copy of the ast. // The reason is that the generation of the operator tree may modify the initial ast, // but if we need to parse for a second time, we would like to parse the unmodified ast." />
      <item value="Check query results cache. // If no masking/filtering required, then we can check the cache now, before // generating the operator tree and going through CBO. // Otherwise we have to wait until after the masking/filtering step." />
      <item value="Check the 1st-level children and do simple semantic checks: 1) CTLT and * CTAS should not coexists. 2) CTLT or CTAS should not coexists with column * list (target table schema). 3) CTAS does not support partitioning (for * now)." />
      <item value="if it is not CTAS, we don't need to go further and just return" />
      <item value="step processPositionAlias out of genResolvedParseTree" />
      <item value="analyze and process the position alias" />
      <item value="replace each of the position alias in GROUPBY with the actual column name" />
      <item value="change the location of position alias process here" />
      <item value="Generate Resolved Parse tree from syntax tree" />
      <item value="put accessed columns to readEntity" />
      <item value="Generate column access stats if required - wait until column pruning" />
      <item value="set ColumnAccessInfo for view column authorization" />
      <item value="Generate table access stats if required" />
      <item value="Take care of view creation" />
      <item value="Deduce Resultset Schema" />
      <item value="gen Resolved Parse Tree" />
      <item value="Resolved Parse Tree" />
      <item value="gen" />
      <item value="analyze create table command" />
      <item value="Assumes one instance of this + single-threaded compilation for each query" />
      <item value="allow partial partition specification for nonscan since noscan is fast." />
      <item value="validate the plan" />
      <item value="A mapping from a tableName to a table object in metastore" />
      <item value="for managed tables, make sure the file formats match" />
      <item value="make sure the arguments make sense" />
      <item value="here" />
      <item value="Retrieve information about cache usage for the query." />
      <item value="Whether any error occurred during query compilation. Used for query lifetime hook" />
      <item value="do the authorization check" />
      <item value="Initialize the transaction manager. This must be done before analyze is called" />
      <item value="save some info for webUI for use after plan is freed" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="414" />
        <entry key="ENGLISH" value="415" />
        <entry key="DUTCH" value="6" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>