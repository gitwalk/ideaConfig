<application>
  <component name="AppStorage">
    <histories>
      <item value="task Info Fetcher" />
      <item value="task Status Fetcher" />
      <item value="Fetch the results from the buffer assigned to the task based on id" />
      <item value="invocation" />
      <item value="stage Execution And Scheduler" />
      <item value="when Split Queue Has Space" />
      <item value="The output buffer depends on the task id starting from 0 and being sequential, since each // task is assigned a private buffer based on task id." />
      <item value="The assumption that `noMoreSplitsNotification.size() &lt;= 1` currently holds. // If this assumption no longer holds, we should consider calling task.noMoreSplits with multiple entries in one shot. // These kind of methods can be expensive since they are grabbing locks and/or sending HTTP requests on change." />
      <item value="assign the splits with successful placements" />
      <item value="assign Splits" />
      <item value="Add an empty split in case no splits have been produced for the source. // For source operators, they never take input, but they may produce output. // This is well handled by Presto execution engine. // However, there are certain non-source operators that may produce output without any input, // for example, 1) an AggregationOperator, 2) a HashAggregationOperator where one of the grouping sets is (). // Scheduling an empty split kicks off necessary driver instantiation to make this work." />
      <item value="calculate placements for splits" />
      <item value="drop Listeners From When Finished Or New Lifespans Added" />
      <item value="Schedules as much work as possible without blocking. * The schedule results is a hint to the query scheduler if and * when the stage scheduler should be invoked again. It is * important to note that this is only a hint and the query * scheduler may call the schedule method at any time." />
      <item value="drain Completely Scheduled Lifespans" />
      <item value="make sure to update stage linkage at least once per loop to catch async state changes (e.g., partial cancel)" />
      <item value="modify parent and children based on the results of the scheduling" />
      <item value="perform some scheduling work" />
      <item value="Apply runtime CBO on the ready sections before creating SectionExecutions." />
      <item value="when query is done or any time a stage completes, attempt to transition query to &quot;final query info ready&quot;" />
      <item value="this is a separate method to ensure that the `this` reference is not leaked during construction" />
      <item value="build the stage execution objects" />
      <item value="create Initial Empty Output Buffers" />
      <item value="Now we will fetch the layout handle if it's not presented in TableHandle. // In the future, ConnectorTableHandle will be used to fetch splits since it will contain layout information." />
      <item value="// acquire reference to scheduler before checking finalQueryInfo, because // state change listener sets finalQueryInfo and then clears scheduler when // the query finishes." />
      <item value="if query was canceled during scheduler creation, abort the scheduler // directly since the callback may have already fired" />
      <item value="build the stage execution objects (this doesn't schedule execution)" />
      <item value="if query was canceled, skip creating scheduler" />
      <item value="ensure split sources are closed" />
      <item value="This notification is triggered after the planning phase completes." />
      <item value="explain Analyze" />
      <item value="ragment the plan // the variableAllocator is finally passed to SqlQueryScheduler for runtime cost-based optimizations" />
      <item value="extract output" />
      <item value="transition To Dispatching" />
      <item value="enqueue Query" />
      <item value="start In Background" />
      <item value="resource Group Manager" />
      <item value="apply system default session properties (does not override user set properties)" />
      <item value="select resource group" />
      <item value="wait for query to be dispatched, up to the wait timeout" />
      <item value="dispatch" />
      <item value="Scan Filter And Project Operator" />
      <item value="Benchmark" />
      <item value="Abstract template for benchmarks that want to test the performance of an Operator" />
      <item value="If there is only one operator, finish it // Some operators (LookupJoinOperator and HashBuildOperator) are broken and requires finish to be called continuously // TODO remove the second part of the if statement, when these operators are fixed // Note: finish should not be called on the natural source of the pipeline as this could cause the task to finish early" />
      <item value="execution Planner" />
      <item value="get Stage Execution Descriptor" />
      <item value="request Memory Revoking" />
      <item value="Semi Transactional Hive Metastore" />
      <item value="begin Statistics Collection" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="863" />
        <entry key="ENGLISH" value="864" />
        <entry key="DANISH" value="2" />
        <entry key="GERMAN" value="1" />
        <entry key="FRENCH" value="3" />
        <entry key="FILIPINO" value="1" />
        <entry key="DUTCH" value="6" />
        <entry key="KURDISH" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="NORWEGIAN" value="1" />
        <entry key="SWEDISH" value="2" />
        <entry key="ITALIAN" value="2" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>