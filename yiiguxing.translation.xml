<application>
  <component name="AppStorage">
    <histories>
      <item value="generate Cache Quota" />
      <item value="coercers" />
      <item value="prefilled Values" />
      <item value="to Bucket Adaptation" />
      <item value="prefilled" />
      <item value="required Interim Columns" />
      <item value="AGGREGATED" />
      <item value="REGULAR" />
      <item value="will be present if the partition has a different schema (column type, column name) for the column" />
      <item value="scheduled Nanos" />
      <item value="running Intermediate Splits" />
      <item value="enqueue Driver Split Runner" />
      <item value="exclusive Lock" />
      <item value="assign" />
      <item value="inline" />
      <item value="create Remote Split For" />
      <item value="abort Results" />
      <item value="Internal Node" />
      <item value="this should be merged into getTaskStatus once full thrift support is in-place for v1/task" />
      <item value="CANCELLED/ABORTED/FAILED" />
      <item value="PRESTO PAGES" />
      <item value="direct Executor" />
      <item value="status" />
      <item value="acknowledge Task Results" />
      <item value="task Info Fetcher" />
      <item value="task Status Fetcher" />
      <item value="Fetch the results from the buffer assigned to the task based on id" />
      <item value="invocation" />
      <item value="stage Execution And Scheduler" />
      <item value="when Split Queue Has Space" />
      <item value="The output buffer depends on the task id starting from 0 and being sequential, since each // task is assigned a private buffer based on task id." />
      <item value="The assumption that `noMoreSplitsNotification.size() &lt;= 1` currently holds. // If this assumption no longer holds, we should consider calling task.noMoreSplits with multiple entries in one shot. // These kind of methods can be expensive since they are grabbing locks and/or sending HTTP requests on change." />
      <item value="assign the splits with successful placements" />
      <item value="assign Splits" />
      <item value="Add an empty split in case no splits have been produced for the source. // For source operators, they never take input, but they may produce output. // This is well handled by Presto execution engine. // However, there are certain non-source operators that may produce output without any input, // for example, 1) an AggregationOperator, 2) a HashAggregationOperator where one of the grouping sets is (). // Scheduling an empty split kicks off necessary driver instantiation to make this work." />
      <item value="calculate placements for splits" />
      <item value="drop Listeners From When Finished Or New Lifespans Added" />
      <item value="Schedules as much work as possible without blocking. * The schedule results is a hint to the query scheduler if and * when the stage scheduler should be invoked again. It is * important to note that this is only a hint and the query * scheduler may call the schedule method at any time." />
      <item value="drain Completely Scheduled Lifespans" />
      <item value="make sure to update stage linkage at least once per loop to catch async state changes (e.g., partial cancel)" />
      <item value="modify parent and children based on the results of the scheduling" />
      <item value="perform some scheduling work" />
      <item value="Apply runtime CBO on the ready sections before creating SectionExecutions." />
      <item value="when query is done or any time a stage completes, attempt to transition query to &quot;final query info ready&quot;" />
      <item value="this is a separate method to ensure that the `this` reference is not leaked during construction" />
      <item value="build the stage execution objects" />
      <item value="create Initial Empty Output Buffers" />
      <item value="Now we will fetch the layout handle if it's not presented in TableHandle. // In the future, ConnectorTableHandle will be used to fetch splits since it will contain layout information." />
      <item value="// acquire reference to scheduler before checking finalQueryInfo, because // state change listener sets finalQueryInfo and then clears scheduler when // the query finishes." />
      <item value="if query was canceled during scheduler creation, abort the scheduler // directly since the callback may have already fired" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="885" />
        <entry key="ENGLISH" value="886" />
        <entry key="DANISH" value="2" />
        <entry key="GERMAN" value="1" />
        <entry key="FRENCH" value="3" />
        <entry key="FILIPINO" value="1" />
        <entry key="DUTCH" value="6" />
        <entry key="KURDISH" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="ROMANIAN" value="1" />
        <entry key="NORWEGIAN" value="1" />
        <entry key="SWEDISH" value="2" />
        <entry key="ITALIAN" value="3" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>