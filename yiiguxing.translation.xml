<application>
  <component name="AppStorage">
    <histories>
      <item value="So, when expanding the definition of v while analyzing the top-level query, * we tag each ASTNode with a reference to an ASTNodeOrign describing v and its * usage within the query." />
      <item value="init Parse Ctx" />
      <item value="Create a clone of the parse context" />
      <item value="Take all the driver run hooks and post-execute them." />
      <item value="// for canceling the query (should be bound to session?)" />
      <item value="/ the reason that we set the txn manager for the cxt here is because each // query has its own ctx object. The txn mgr is shared across the // same instance of Driver, which can run multiple queries." />
      <item value="compile internal will automatically reset the perf logger" />
      <item value="// the reason that we set the txn manager for the cxt here is because each // query has its own ctx object. The txn mgr is shared across the // same instance of Driver, which can run multiple queries." />
      <item value="Snapshot was outdated when locks were acquired, hence regenerate context, // txn list and retry // TODO: Lock acquisition should be moved before analyze, this is a bit hackish. // Currently, we acquire a snapshot, we compile the query wrt that snapshot, // and then, we acquire locks. If snapshot is still valid, we continue as usual. // But if snapshot is not valid, we recompile the query." />
      <item value="Since we're reusing the compiled plan, we need to update its start time for current run" />
      <item value="/*Some HiveExceptions (e.g. SemanticException) don't set canonical ErrorMsg explicitly, but there is logic (e.g. #compile()) to find an appropriate canonical error and return its code as error code. In this case we want to preserve it for downstream code to interpret*/" />
      <item value="/*Here we want to encode the error in machine readable way (e.g. JSON) * Ideally, errorCode would always be set to a canonical error defined in ErrorMsg. * In practice that is rarely the case, so the messy logic below tries to tease * out canonical error code if it can. Exclude stack trace from output when * the error is a specific/expected one. * It's written to stdout for backward compatibility (WebHCat consumes it).*/" />
      <item value="ExecuteWithHookContext is a new interface that the Pre/Post Execute Hook can run with the HookContext" />
      <item value="Based on the plan outputs, find out the target table name and column names" />
      <item value="Subclasses" />
      <item value="classLoader the class loader to create the proxy with" />
      <item value="Create a new proxy according to the settings in this factory. * &lt;p&gt;Can be called repeatedly. Effect will vary if we've added * or removed interfaces. Can add and remove interceptors. * &lt;p&gt;Uses the given class loader (if necessary for proxy creation)." />
      <item value="Uses the given class loader (if necessary for proxy creation)" />
      <item value="Can add and remove interceptors" />
      <item value="Effect will vary if we've added * or removed interfaces." />
      <item value="Can be called repeatedly" />
      <item value="the cache key for metadata access" />
      <item value="the raw bean instance" />
      <item value="Wrap the given bean if necessary, i.e. if it is eligible for being proxied" />
      <item value="Create a proxy with the configured interceptors if the bean is * identified as one to proxy by the subclass." />
      <item value="initialize Bean" />
      <item value="Make sure bean class is actually resolved at this point" />
      <item value="Give BeanPostProcessors a chance to return a proxy instead of the target bean instance" />
      <item value="// Make sure bean class is actually resolved at this point, and // clone the bean definition in case of a dynamically resolved Class // which cannot be stored in the shared merged bean definition." />
      <item value="Check if required type matches the type of the actual bean instance" />
      <item value="While this may not be part of the regular factory bootstrap, it does otherwise work fine" />
      <item value="Iterate over a copy to allow for init methods which in turn register new bean definitions" />
      <item value="Instantiate all remaining (non-lazy-init) singletons" />
      <item value="// Register a default embedded value resolver if no bean post-processor // (such as a PropertyPlaceholderConfigurer bean) registered any before: // at this point, primarily for resolution in annotation attribute values." />
      <item value="Allows post-processing of the bean factory in context subclasses." />
      <item value="Register bean processors that intercept bean creation" />
      <item value="// Register BeanPostProcessorChecker that logs an info message when // a bean is created during BeanPostProcessor instantiation, i.e. when // a bean is not eligible for getting processed by all BeanPostProcessors." />
      <item value="separator" />
      <item value="Initialization" />
      <item value="1. `spring-core` and `spring-oxm` should be pre-compiled due to repackaged dependencies. See `*RepackJar` tasks in the build and https://youtrack.jetbrains.com/issue/IDEA-160605). 2. `spring-aspects` does not compile due to references to aspect types unknown to IntelliJ IDEA. See https://youtrack.jetbrains.com/issue/IDEA-64446 for details. In the meantime, the 'spring-aspects' can be excluded from the project to avoid compilation errors. 3. While JUnit tests pass from the command line with Gradle, some may fail when run from IntelliJ IDEA. Resolving this is a work in progress. If attempting to run all JUnit tests from within IntelliJ IDEA, you will likely need to set the following VM options to avoid out of memory errors: -XX:MaxPermSize=2048m -Xmx2048m -XX:MaxHeapSize=2048m 4. If you invoke &quot;Rebuild Project&quot; in the IDE, you'll have to generate some test resources of the `spring-oxm` module again (`./gradlew :spring-oxm:compileTestJava`)" />
      <item value="Navigate" />
      <item value="When prompted exclude the `spring-aspects` module (or after the import via File-&gt; Project Structure -&gt; Modules) 4. Code away" />
      <item value="CREDENTIALS" />
      <item value="/** * Used to dereference a {@link FactoryBean} instance and distinguish it from * beans &lt;i&gt;created&lt;/i&gt; by the FactoryBean. For example, if the bean named * {@code myJndiObject} is a FactoryBean, getting {@code &amp;myJndiObject} * will return the factory, not the instance returned by the factory. */" />
      <item value="Mapped Statements collection does not contain value for com.bupt.cad.metadataserver.dao.DictionaryDao.findByDictCode" />
      <item value="The Web UI provides navigation between the bits of information and the ability to annotate the collected data with comments, ownership and more. The example below is for collecting Hive metadata collected from the Cloudera Hadoop VM Wherehows comes in three operational components: - [Backend service](../wherehows-backend/README.md) - **A web-ui service** - Database schema for MySQL" />
      <item value="return all declared fields of the class, exclude inherited fields" />
      <item value="stagging table for dataset" />
      <item value="/** * The DataOriginView class is used to find our dataset data origin. Previously, the values EI, CORP, and PROD * were hardcoded into the frontend UI, but users actually wanted even more information about the cluster the * data lives on (e.g. Holdem, War). */" />
      <item value="Lineage" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="161" />
        <entry key="ENGLISH" value="162" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>